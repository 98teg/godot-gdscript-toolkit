start: class_stmt*

class_stmt: (simple_class_stmt _NL) | compound_class_stmt | _NL | empty_block
simple_class_stmt: tool_stmt
                 | signal_stmt
                 | extends_stmt
                 | classname_stmt
                 | class_var_stmt
                 | const_stmt
                 | export_stmt
                 | onready_stmt
compound_class_stmt: class_def
                   | enum_def
                   | "static" func_def -> static_func_def
                   | func_def
empty_block: _INDENT _NL* _DEDENT

tool_stmt: "tool"
signal_stmt: "signal" NAME [ "(" NAME ("," NAME)* ")" ]
extends_stmt: "extends" (NAME | string ("." NAME)*)
classname_stmt: "class_name" NAME [ "," string ]
export_stmt: export_inf | export_typed
export_inf: "export" (var_assigned | var_typed | var_typed_assgnd | var_inf) [setget]
export_typed: "export" "(" TYPE ")" class_var_stmt
class_var_stmt: var_stmt [setget]
var_stmt: var_empty
        | var_assigned
        | var_typed
        | var_typed_assgnd
        | var_inf
var_empty: "var" NAME
var_assigned: "var" NAME "=" expr
var_typed: "var" NAME ":" TYPE
var_typed_assgnd: var_typed "=" expr
var_inf: "var" NAME ":=" expr
setget: "setget" [NAME] ["," NAME]
const_stmt: "const" NAME "=" expr
onready_stmt: "onready" class_var_stmt

class_def: "class" NAME ":" class_body
class_body: _NL _INDENT class_stmt_chain _DEDENT
class_stmt_chain: class_stmt* [simple_class_stmt]

func_def: "func" NAME "(" [func_args] ")" ["->" TYPE] ":" func_body
func_args: func_arg ("," func_arg)*
         | _NL _INDENT func_arg ("," _NL* func_arg)* _NL _DEDENT
func_arg: func_arg_regular
        | func_arg_inf
        | func_arg_typed
func_arg_regular: ["var"] NAME ["=" expr]
func_arg_inf: ["var"] NAME ":=" expr
func_arg_typed: ["var"] NAME ":" TYPE ["=" expr]
func_body: _NL _INDENT func_stmt_chain _DEDENT
func_stmt_chain: func_stmt* [simple_func_stmt]
func_stmt: (simple_func_stmt _NL) | compound_func_stmt | _NL
simple_func_stmt: pass_stmt
                | return_stmt
                | func_var_stmt
                | expr
compound_func_stmt: if_stmt
                  | while_stmt
                  | for_stmt
                  | match_stmt
pass_stmt: "pass"
return_stmt: "return" [expr]
func_var_stmt: var_stmt
if_stmt: "if" expr ":" func_body (_NL* "elif" expr ":" func_body)* [ _NL* "else" ":" func_body ]
while_stmt: "while" expr ":" func_body
for_stmt: "for" NAME "in" expr ":" func_body
match_stmt: "match" expr ":" match_body
match_body: _NL _INDENT match_branch+ _DEDENT
match_branch: (expr | "_") ":" _NL _INDENT func_stmt+ _DEDENT

enum_def: (enum_regular | enum_named) _NL
enum_regular: "enum" enum_body
enum_named: "enum" NAME enum_body
enum_body: "{" _WS* [ (enum_entry [ "," ] _WS*)* ] "}"
enum_entry: NAME

expr: test_expr
    | assnmtn_expr
assnmtn_expr: lvalue assnmtn_op expr
assnmtn_op: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|="
lvalue: attr_expr             // TODO: shrink, it's too wide probably
test_expr: or_test ["if" or_test "else" test_expr]
or_test: and_test (("or" | "||") and_test)*
and_test: not_test (("and" | "&&") not_test)*
not_test: ("not" | "!") not_test | content_test
content_test: comparison ("in" comparison)*
comparison: bitw_or (comp_op bitw_or)*
comp_op: ">" | "<" | "==" | "!=" | "<=" | ">="
bitw_or: bitw_xor ("|" bitw_xor)*
bitw_xor: bitw_and ("^" bitw_and)*
bitw_and: shift_expr ("&" shift_expr)*
shift_expr: subtr_expr (("<<"|">>") subtr_expr)*
subtr_expr: addn_expr ("-" addn_expr)*
addn_expr: mdr_expr ("+" _f* mdr_expr)*
mdr_expr: neg_expr (("*" | "/" | "%") neg_expr)*
neg_expr: "-" neg_expr | bitw_not
bitw_not: "~" bitw_not | type_test
type_test: type_cast ("is" attr_expr)*
type_cast: attr_expr ("as" TYPE)* // TODO: check precedence
attr_expr: subscr_expr ("." subscr_expr)*
subscr_expr: subscr_expr "[" expr "]"
           | (call_expr | atom)
call_expr: ["."] call // TODO: check precedence
call: generic_call
    | indented_call
    | indented_call2
    | indented_call3
generic_call: NAME "(" [_f* expr (_f* "," _f* expr)*] _f* ")"
indented_call: NAME "(" expr _NL _INDENT ")" _NL* _DEDENT
indented_call2: NAME "(" _NL _INDENT expr ("," _NL* expr)* ")" _NL* _DEDENT
indented_call3: NAME "(" _NL _INDENT expr ("," _NL* expr)* _NL* _DEDENT ")"
atom: "(" expr ")"
    | array
    | dict
    | NAME
    | literal
literal: NUMBER
       | string
       | node_path
       | get_node
node_path: "@" string
get_node: "$" (path | string)
path: NAME ("/" NAME)*
array: "[" _f* [expr _f* ("," _f* expr _f*)* ["," _f*]] "]" // TODO: fix dat hacks?
dict: "{" _f* [attr_expr ":" _f* expr _f* ("," _f* attr_expr ":" _f* expr _f*)* ["," _f*]] "}"
    | "{" _f* [attr_expr "=" _f* expr _f* ("," _f* attr_expr "=" _f* expr _f*)* ["," _f*]] "}"
_f: _NL | _INDENT | _DEDENT

TYPE: NAME
_NL: /(\r?\n[\t ]*)+/
_WS: WS
string: REGULAR_STRING | LONG_STRING
REGULAR_STRING: /("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
LONG_STRING.2: /""".*?(?<!\\)(\\\\)*?"""/is
COMMENT: /#[^\n]*/
LINE_CONT: /\\[\t \f]*\r?\n/

%declare _INDENT _DEDENT

%ignore WS_INLINE
%ignore COMMENT
%ignore LINE_CONT

%import common.NUMBER
%import common.WS
%import common.WS_INLINE
%import common.CNAME -> NAME
%import common.ESCAPED_STRING
%import common._STRING_ESC_INNER
