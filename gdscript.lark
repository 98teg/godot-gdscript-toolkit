start: (_NL | class_stmt)*

class_stmt: (simple_class_stmt _NL) | compound_class_stmt
simple_class_stmt: tool_stmt
                 | signal_stmt
                 | extends_stmt
                 | classname_stmt
                 | var_stmt
                 | const_stmt
                 | export_stmt
                 | onready_stmt
compound_class_stmt: class_def
                   | enum_def
                   | func_def

tool_stmt: "tool"
signal_stmt: "signal" NAME [ "(" NAME ("," NAME)* ")" ]
extends_stmt: "extends" NAME
classname_stmt: "class_name" NAME
export_stmt: export_inf | export_typed
export_inf: "export" var_assigned
export_typed: "export(" TYPE ")" var_stmt
var_stmt: var_empty | var_assigned
var_empty: "var" NAME
var_assigned: "var" NAME "=" expr
const_stmt: "const" NAME "=" expr
onready_stmt: "onready" var_stmt

class_def: "class" NAME ":" suite
suite: _NL _INDENT class_stmt+ _DEDENT

func_def: "func" NAME "():" func_body
func_body: _NL _INDENT func_stmt+ _DEDENT
func_stmt: simple_func_stmt _NL | compound_func_stmt
simple_func_stmt: pass_stmt
                | var_stmt
                | expr
compound_func_stmt: if_stmt
                  | while_stmt
                  | for_stmt
                  // TODO: match
pass_stmt: "pass"
if_stmt: "if" expr ":" func_body ("elif" expr ":" func_body)* [ "else" ":" func_body ]
while_stmt: "while" expr ":" func_body
for_stmt: "for" NAME "in" expr ":" func_body

enum_def: enum_regular | enum_named
enum_regular: "enum" enum_body
enum_named: "enum" NAME enum_body
enum_body: "{" _WS* [ (enum_entry [ "," ] _WS*)* ] "}"
enum_entry: NAME

expr: NAME | NUMBER

TYPE: NAME
_NL: /(\r?\n[\t ]*)+/
_WS: WS

%declare _INDENT _DEDENT

%ignore WS_INLINE

%import common.NUMBER
%import common.WS
%import common.WS_INLINE
%import common.CNAME -> NAME
