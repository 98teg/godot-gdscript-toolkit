start: (_NL | class_stmt)*

class_stmt: (simple_class_stmt _NL) | compound_class_stmt
simple_class_stmt: tool_stmt
                 | signal_stmt
                 | extends_stmt
                 | classname_stmt
                 | var_stmt
                 | const_stmt
                 | export_stmt
                 | onready_stmt
compound_class_stmt: class_def
                   | enum_def
                   | func_def

tool_stmt: "tool"
signal_stmt: "signal" NAME [ "(" NAME ("," NAME)* ")" ]
extends_stmt: "extends" (NAME | STRING ("." NAME)*)
classname_stmt: "class_name" NAME [ "," STRING ]
export_stmt: export_inf | export_typed
export_inf: "export" var_assigned
export_typed: "export(" TYPE ")" var_stmt
var_stmt: var_empty | var_assigned
var_empty: "var" NAME
var_assigned: "var" NAME "=" expr
const_stmt: "const" NAME "=" expr
onready_stmt: "onready" var_stmt

class_def: "class" NAME ":" suite
suite: _NL _INDENT class_stmt+ _DEDENT

func_def: "func" NAME "():" func_body
func_body: _NL _INDENT func_stmt+ _DEDENT
func_stmt: simple_func_stmt _NL | compound_func_stmt
simple_func_stmt: pass_stmt
                | var_stmt
                | expr
compound_func_stmt: if_stmt
                  | while_stmt
                  | for_stmt
                  // TODO: match
pass_stmt: "pass"
if_stmt: "if" expr ":" func_body ("elif" expr ":" func_body)* [ "else" ":" func_body ]
while_stmt: "while" expr ":" func_body
for_stmt: "for" NAME "in" expr ":" func_body

enum_def: enum_regular | enum_named
enum_regular: "enum" enum_body
enum_named: "enum" NAME enum_body
enum_body: "{" _WS* [ (enum_entry [ "," ] _WS*)* ] "}"
enum_entry: NAME

expr: test_expr
test_expr: or_test ["if" or_test "else" test_expr]
or_test: and_test (("or" | "||") and_test)*
and_test: not_test (("and" | "&&") not_test)*
not_test: ("not" | "!") not_test | content_test
content_test: comparison ("in" comparison)*
comparison: bitw_or (comp_op bitw_or)*
comp_op: ">" | "<" | "==" | "!=" | "<=" | ">="
bitw_or: bitw_xor ("|" bitw_xor)*
bitw_xor: bitw_and ("^" bitw_and)*
bitw_and: shift_expr ("&" shift_expr)*
shift_expr: subtr_expr (("<<"|">>") subtr_expr)*
subtr_expr: addn_expr ("-" addn_expr)*
addn_expr: mdr_expr ("+" mdr_expr)*
mdr_expr: neg_expr (("*" | "/" | "%") neg_expr)*
neg_expr: "-" neg_expr | bitw_not
bitw_not: "~" bitw_not | type_test
type_test: attr_expr ("is" atom)*
attr_expr: subscr_expr ("." NAME)*
subscr_expr: call_expr ["[" atom "]"] // TODO: expr inside []
call_expr: atom ["(" ")"]             // TODO: expr(s,) inside ()
atom: "(" expr ")"
    | array
    | dict
    | NAME
    | literal
literal: NUMBER
       | STRING
       | node_path
       | get_node
node_path: "@" STRING                // TODO: check if 'x' or """x""" applies
get_node: "$" (NAME | STRING)        // TODO: same
array: "[" _f* [expr _f* ("," _f* expr _f*)* ["," _f*]] "]" // TODO: fix dat hacks?
dict: "{" _f* [expr ":" expr _f* ("," _f* expr ":" expr _f*)* ["," _f*]] "}"
_f: _NL | _INDENT | _DEDENT

TYPE: NAME
_NL: /(\r?\n[\t ]*)+/
_WS: WS
STRING: /'[^']*'/
      | /"""[^"]*"""/           // TODO: fix & extend
      | ESCAPED_STRING
COMMENT: /#[^\n]*/

%declare _INDENT _DEDENT

%ignore WS_INLINE
%ignore COMMENT

%import common.NUMBER
%import common.WS
%import common.WS_INLINE
%import common.CNAME -> NAME
%import common.ESCAPED_STRING
